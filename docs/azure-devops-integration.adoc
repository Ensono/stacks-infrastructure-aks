---
id: aks_azure_devops_integration
title: Azure DevOps Integration
description: Azure DevOps integration details including PAT validation and variable group management.
weight: 45
---

:toc:

== Azure DevOps Integration

This guide explains how Azure DevOps (ADO) integrates with the infrastructure pipeline, including PAT validation, variable group creation, and security considerations.

=== PAT Validation Workflow

The ADO Personal Access Token (PAT) is used by Terraform to create and update Variable Groups. The validation task runs early to fail fast when scopes or permissions are missing.

[graphviz]
----
include::diagrams/pat-validation-pipeline.dot[]
----

Steps:

. PAT is provided via `TF_VAR_ado_personal_access_token`.
. `setup:validate:azdo:pat` checks required scopes.
. The task verifies read permissions and attempts a create/delete test variable group.
. The pipeline continues only if validation succeeds.

=== Variable Group Generation

Variable groups are created by Terraform (via the `azuredevops` provider) when `TF_VAR_create_ado_variable_group=true`.

Structure:

* `stacks-<stage>-vars` (default) – contains environment-specific values
* Standardized keys for Terraform and pipeline integration

App Configuration Integration:

When Azure App Configuration is used, variable groups can be synced from Azure App Configuration to ADO. This provides:

* Centralized configuration management
* Consistency across environments
* Secure secret handling via Key Vault
* Change tracking and auditability

To enable App Configuration synchronization, set the `TF_VAR_sync_app_configuration=true` environment variable during deployment.

=== Pipeline Script Logic

The deployment scripts implement the following logic flow:

. **PAT Validation**: Early validation to fail fast on permission issues
. **Environment Setup**: Load and validate all TF_VAR_* environment variables
. **Terraform Lifecycle**:
  - Format validation and linting
  - Workspace initialization (`infra:init`)
  - Plan generation with artifacts for review
  - Apply with state locking
. **Helm Deployment**: Execute Helm charts using Terraform outputs
. **State Cleanup**: Clear any Terraform state locks (always runs, even on failure)

This hierarchical approach ensures dependencies are managed, failures are logged, and resources are cleaned up appropriately.

=== Required PAT Scopes

Minimum required scopes for this repository:

The Terraform `azuredevops` provider requires the following scopes to create and manage variable groups:

* Project and Team: Read (`vso.project`) – required to read project metadata
* Work Items: Read (`vso.work`) – required to read process templates
* Build: Read (`vso.build`) – required to read project resources and permissions
* Variable Groups: Read & manage (`vso.variablegroups_manage`) – required to create and manage variable groups

Optional (only if required by future changes):

* Pipeline resources: Use and manage (`vso.pipelineresources_manage`)

=== Security Best Practices

IMPORTANT: Never hardcode PATs. Use secure variable groups or a secrets manager.

* Use least-privilege scopes
* Set short PAT expiration
* Rotate PATs regularly
* Store tokens in secret variables or Key Vault

=== Troubleshooting PAT Validation

Common failures:

* Missing scopes
* Expired token
* Insufficient permissions in the ADO project

Remediation:

. Confirm scopes against the list above
. Recreate the PAT with the correct scopes
. Re-run `eirctl run setup:validate:azdo:pat`

See xref:troubleshooting.adoc[Troubleshooting] for detailed error scenarios.

=== Deployment Stages

The pipeline uses conditional stages to manage environment-specific deployments:

**NonProd Stage**:

* Triggered on feature branches (not master)
* Deploys to non-production environments
* Runs infrastructure tests and validation
* No external artifacts published
* Shorter TTL for temporary resources

**Prod Stage**:

* Triggered only on master branch
* Requires all previous stages to succeed
* Production-level compliance and security checks
* Artifact retention for compliance auditing
* External artifact publishing (optional)

**Release Stage**:

* Depends on successful NonProd or Prod (based on branch)
* Creates GitHub releases with version tags
* Publishes documentation artifacts
* Only runs after infrastructure deployment succeeds
