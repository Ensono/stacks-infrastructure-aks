---
id: aks_azure_devops_integration
title: Azure DevOps Integration
description: Azure DevOps integration details including PAT validation and variable group management.
weight: 45
---

:toc:

== Azure DevOps Integration

This guide explains how Azure DevOps (ADO) integrates with the infrastructure pipeline, including PAT validation, variable group creation, and security considerations.

=== PAT Validation Workflow

The ADO Personal Access Token (PAT) is used by Terraform to create and update Variable Groups. The validation task runs early to fail fast when scopes or permissions are missing.

[graphviz]
----
include::diagrams/pat-validation-pipeline.dot[]
----

Steps:

. PAT is provided via `TF_VAR_ado_personal_access_token`.
. `setup:validate:azdo:pat` checks required scopes.
. The task verifies read permissions and attempts a create/delete test variable group.
. The pipeline continues only if validation succeeds.

=== Variable Group Generation

Variable groups are created by Terraform (via the `azuredevops` provider) when `TF_VAR_create_ado_variable_group=true`.

Structure:

* `stacks-<stage>-vars` (default) – contains environment-specific values
* Standardized keys for Terraform and pipeline integration

App Configuration Integration:

When Azure App Configuration is used, variable groups can be synced from Azure App Configuration to ADO. This provides:

* Centralized configuration management
* Consistency across environments
* Secure secret handling via Key Vault
* Change tracking and auditability

To enable App Configuration synchronization, set the `TF_VAR_sync_app_configuration=true` environment variable during deployment.

=== Pipeline Script Logic

The deployment scripts implement the following logic flow:

. **PAT Validation**: Early validation to fail fast on permission issues
. **Environment Setup**: Load and validate all TF_VAR_* environment variables
. **Terraform Lifecycle**:
  - Format validation and linting
  - Workspace initialization (`infra:init`)
  - Plan generation with artifacts for review
  - Apply with state locking
. **Helm Deployment**: Execute Helm charts using Terraform outputs
. **State Cleanup**: Clear any Terraform state locks (always runs, even on failure)

This hierarchical approach ensures dependencies are managed, failures are logged, and resources are cleaned up appropriately.

=== Required PAT Scopes

Minimum required scopes for this repository:

The Terraform `azuredevops` provider requires the following scopes to create and manage variable groups:

* Project and Team: Read (`vso.project`) – required to read project metadata
* Work Items: Read (`vso.work`) – required to read process templates
* Build: Read (`vso.build`) – required to read project resources and permissions
* Variable Groups: Read & manage (`vso.variablegroups_manage`) – required to create and manage variable groups

Optional (only if required by future changes):

* Pipeline resources: Use and manage (`vso.pipelineresources_manage`)

=== Security Best Practices

IMPORTANT: Never hardcode PATs. Use secure variable groups or a secrets manager.

* Use least-privilege scopes
* Set short PAT expiration
* Rotate PATs regularly
* Store tokens in secret variables or Key Vault

=== Troubleshooting PAT Validation

Common failures:

* Missing scopes
* Expired token
* Insufficient permissions in the ADO project

Remediation:

. Confirm scopes against the list above
. Recreate the PAT with the correct scopes
. Re-run `eirctl run setup:validate:azdo:pat`

See xref:troubleshooting.adoc[Troubleshooting] for detailed error scenarios.

=== Deployment Stages

The pipeline uses conditional stages to manage environment-specific deployments. Stages are defined as a parameter object in the pipeline YAML, allowing for flexible multi-environment deployments.

==== Stage Configuration Structure

Stages are defined using the `stages` parameter in `deploy-infrastructure.yml`:

[source,yaml]
----
parameters:
  - name: stages
    type: object
    default:
      - stage: NonProd
        dependsOn: Build
        condition: ne(variables['Build.SourceBranch'], 'refs/heads/master')
        environment_shortname: nonprod
        dns_zone: $(base_domain_nonprod)
        domain_internal: $(base_domain_internal_nonprod)
        deployment_infra: InfraNonProd
        deployment_apps: K8sNonProd
        is_prod_subscription: false
      - stage: Prod
        dependsOn: Build
        condition: eq(variables['Build.SourceBranch'], 'refs/heads/master')
        environment_shortname: prod
        dns_zone: $(base_domain_prod)
        domain_internal: $(base_domain_internal_prod)
        deployment_infra: InfraProd
        deployment_apps: K8sProd
        is_prod_subscription: true
----

==== Stage Configuration Fields

[cols="2,1,4",options="header",stripes=even]
|===
| Field | Type | Description

| `stage`
| string
| Azure DevOps stage name (displayed in pipeline UI)

| `dependsOn`
| string
| Stage dependency - typically `Build` for deployment stages

| `condition`
| expression
| Azure DevOps condition expression determining when the stage runs (e.g., branch-based routing)

| `environment_shortname`
| string
| Maps to `TF_VAR_stage` - determines Terraform workspace, resource naming suffix, and environment configuration. Common values: `dev`, `nonprod`, `prod`

| `dns_zone`
| string
| Public DNS zone for external-facing ingress endpoints (e.g., `example.nonprod.com`)

| `domain_internal`
| string
| Private DNS zone for internal cluster services (e.g., `internal.nonprod.local`)

| `deployment_infra`
| string
| Azure DevOps deployment job name for infrastructure provisioning

| `deployment_apps`
| string
| Azure DevOps deployment job name for Helm chart deployments

| `is_prod_subscription`
| boolean
| Flags production environment for enhanced security controls, compliance checks, and audit logging. Set `true` only for production subscriptions.
|===

==== Default Stage Definitions

**NonProd Stage**:

* Triggered on feature branches (not master)
* `environment_shortname: nonprod` - creates resources with `-nonprod` suffix
* `is_prod_subscription: false` - relaxed security policies for development
* Runs infrastructure tests and validation
* No external artifacts published
* Shorter TTL for temporary resources

**Prod Stage**:

* Triggered only on master branch
* `environment_shortname: prod` - creates resources with `-prod` suffix
* `is_prod_subscription: true` - enforces production-grade security and compliance
* Requires all previous stages to succeed
* Production-level compliance and security checks
* Artifact retention for compliance auditing
* External artifact publishing (optional)

**Release Stage**:

* Depends on successful NonProd or Prod (based on branch)
* Creates GitHub releases with version tags
* Publishes documentation artifacts
* Only runs after infrastructure deployment succeeds

==== Customizing Stages

To add custom stages (e.g., QA, Staging), modify the `stages` parameter in your pipeline:

[source,yaml]
----
parameters:
  - name: stages
    type: object
    default:
      - stage: Dev
        dependsOn: Build
        condition: startsWith(variables['Build.SourceBranch'], 'refs/heads/feature/')
        environment_shortname: dev
        dns_zone: $(base_domain_dev)
        domain_internal: $(base_domain_internal_dev)
        deployment_infra: InfraDev
        deployment_apps: K8sDev
        is_prod_subscription: false
      - stage: QA
        dependsOn: Build
        condition: eq(variables['Build.SourceBranch'], 'refs/heads/qa')
        environment_shortname: qa
        dns_zone: $(base_domain_qa)
        domain_internal: $(base_domain_internal_qa)
        deployment_infra: InfraQA
        deployment_apps: K8sQA
        is_prod_subscription: false
      - stage: Prod
        dependsOn: Build
        condition: eq(variables['Build.SourceBranch'], 'refs/heads/master')
        environment_shortname: prod
        dns_zone: $(base_domain_prod)
        domain_internal: $(base_domain_internal_prod)
        deployment_infra: InfraProd
        deployment_apps: K8sProd
        is_prod_subscription: true
----

IMPORTANT: Ensure corresponding DNS zone variables (e.g., `base_domain_dev`, `base_domain_qa`) are defined in `pipeline-vars.yml` and Azure DevOps variable groups.

==== Stage-to-Environment Mapping

The `environment_shortname` field controls:

* **Terraform Workspace**: Workspace name matches `environment_shortname` (e.g., `nonprod`, `prod`)
* **Resource Naming**: All resources include the stage in their name pattern: `{company}-{project}-{stage}-{component}`
* **Configuration Selection**: Environment-specific values from `build/config/stage_envvars.yml`
* **State File Isolation**: Separate Terraform state per environment

==== is_prod_subscription Flag

The `is_prod_subscription` boolean enables production-specific behaviors:

* Enhanced Azure Policy enforcement
* Stricter RBAC and network security rules
* Enabled audit logging and retention policies
* Production SKU selection (e.g., Standard vs Premium tiers)
* Change approval gates and deployment windows

Set `is_prod_subscription: true` only for production environments to maintain security posture and compliance requirements.
