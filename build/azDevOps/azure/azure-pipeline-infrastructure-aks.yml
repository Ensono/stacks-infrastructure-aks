#############################################################################################################################
# This is a generated file which includes some replacements.                                                                #
# It is still very much recommended to go through this and ensure all variables are correct for your business/domain        #
# All variables are defined in a global scope.                                                                              #
# All Terraform produced resource names are using a labels module ensuring a predictable naming convention                  #
# E.g.: variables for company, project, stage and domain will produce a name of `$company-$project-$stage-$domain`          #
# NB: Some resources e.g. blob storage only allow for alpha numeric characters so the name is adjusted accordingly          #
#  ==> `$company$project$stage$domain`                                                                                      #
#############################################################################################################################
name: '$(Build.SourceBranchName)-init'

pr:
  - master

trigger:
  branches:
    include:
      - 'master'
  paths:
    include:
      - '*'

resources:
  repositories:
    - repository: templates
      type: github
      name: amido/stacks-pipeline-templates
      # ref: refs/tags/v2.0.1
      ref: feat/ingress-nginx-helm
      endpoint: amidostacks
  containers:
    - container: k8s_deploy
      image: amidostacks/ci-k8s:0.1.2
    - container: terraform_custom
      image: amidostacks/ci-tf:0.0.8

variables:
  - template: azuredevops-vars.yml

  # Versioning
  - name: version_major
    value: 0
  - name: version_minor
    value: 0
  - name: version_revision
    value: $[counter(join(variables['version_major'], join('-', variables['version_minor'])), 0)]
  - name: version_build_number
    value: "$(version_major).$(version_minor).$(version_revision)-$(Build.SourceBranchName)"

  # SelfConfig
  - name: self_repo_dir
    value: "$(Agent.BuildDirectory)/s/$(self_repo)"
  - name: self_repo_tf_src
    value: deploy/azure/infra/stacks-aks
  - name: self_repo_tf_dir
    value: "$(self_repo_dir)/$(self_repo_tf_src)"
  - name: self_pipeline_repo
    value: "$(Agent.BuildDirectory)/s/stacks-pipeline-templates"
  - name: self_pipeline_scripts_dir
    value: "$(self_pipeline_repo)/scripts"

  # k8s
  - name: k8s_manifest_directory
    value: "$(self_repo_dir)/deploy/k8s_manifests"
  - name: helm_manifest_directory
    value: "$(self_repo_dir)/deploy/helm_manifests"

  # Scripts directory used by pipeline steps
  - name: scripts_dir
    value: $(Agent.BuildDirectory)/s/stacks-pipeline-templates/azDevOps/azure/templates/v2/scripts

  # AKS/AZURE
  # This will always be predictably named by setting your company - project - stage - location - compnonent names above
  # IT IS SET per stage as an output to be consumed by deploy stage
  - name: aks_cluster_version
    value: "1.24.6"

  # DEFAULT IMAGE RUNNER
  - name: pool_vm_image
    value: ubuntu-20.04

  # Yamllint
  - name: yamllint_config_file
    value: "${{ variables.self_repo_dir }}/yamllint.conf"
  - name: yamllint_scan_directory
    value: "."


stages:
  - stage: Build
    jobs:
      - job: Validate
        pool:
          vmImage: $(pool_vm_image)
        steps:
          - checkout: self

          - checkout: templates

          # Updates the build number in Azure DevOps (requires refresh in the UI to see)
          - bash: |
              echo '##vso[build.updatebuildnumber]$(version_build_number)'
            displayName: 'Update: Build Number'

          # Validates all YAML files in the repo to check they adhere to standards
          - template: azDevOps/azure/templates/v3/steps/build/test-validate-yaml.yml@templates
            parameters:
              pipeline_scripts_directory: "${{ variables.self_pipeline_scripts_dir }}"
              container: "k8s_deploy"
              yamllint_config_file: "${{ variables.yamllint_config_file }}"
              yamllint_scan_directory: "${{ variables.yamllint_scan_directory }}"

          # Runs a terraform fomatting check and a validation check
          - template: azDevOps/azure/templates/v3/steps/build/test-validate-terraform.yml@templates
            parameters:
              pipeline_scripts_directory: "${{ variables.self_pipeline_scripts_dir }}"
              terraform_container: "terraform_custom"
              terraform_directory: "${{ variables.self_repo_tf_dir }}"

  # Called Non-Prod instead of Dev as all Non-Production stages will deploy to here
  - stage: NonProd
    dependsOn: Build
    condition: and(succeeded(), ne(variables['Build.SourceBranch'], 'refs/heads/master'))
    variables:
      - group: amido-stacks-infra-credentials-nonprod

      # Pull in the non-production credentials for the build to use
      - group: stacks-credentials-nonprod-kv
      - name: Environment.ShortName
        value: nonprod
    jobs:
      - deployment: InfraNonProd
        environment: ${{ variables.domain }}-nonprod
        variables:
          ARM_SUBSCRIPTION_ID: $(azure-subscription-id)
          ARM_CLIENT_ID: $(azure-client-id)
          ARM_CLIENT_SECRET: $(azure-client-secret)
          ARM_TENANT_ID: $(azure-tenant-id)
        pool:
          vmImage: $(pool_vm_image)
        container: terraform_custom
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self

                - checkout: templates

                # Create TF infra
                - template: azDevOps/azure/templates/v2/steps/deploy-terraform-resource.yml@templates
                  parameters:
                    # Terraform Basic Config
                    terraform_working_dir: '$(self_repo_tf_dir)'
                    # changing this would require changing the downstream consumers of these outputs
                    terraform_output_artefact: 'tfoutputs'
                    # Terraform State Config
                    terraform_backend_client_id: $(ARM_CLIENT_ID)
                    terraform_backend_client_secret: $(ARM_CLIENT_SECRET)
                    terraform_backend_tenant_id: $(ARM_TENANT_ID)
                    terraform_backend_subscription_id: $(ARM_SUBSCRIPTION_ID)
                    terraform_state_rg: $(tf_state_rg)
                    terraform_state_storage: $(tf_state_storage)
                    terraform_state_container: $(tf_state_container)
                    terraform_state_key: $(tf_state_key)
                    terraform_state_workspace: nonprod
                    # Azure Config
                    azure_client_id: "$(ARM_CLIENT_ID)"
                    azure_client_secret: "$(ARM_CLIENT_SECRET)"
                    azure_tenant_id: "$(ARM_TENANT_ID)"
                    azure_subscription_id: "$(ARM_SUBSCRIPTION_ID)"
                    tags: ''
                    # Terraform Resource Specific Config
                    terraform_extra_properties: {
                      TF_VAR_resource_group_location: $(region),
                      TF_VAR_name_company: $(company),
                      TF_VAR_name_project: $(project),
                      TF_VAR_name_component: $(domain),
                      TF_VAR_name_environment: nonprod,
                      TF_VAR_create_acr: true,
                      TF_VAR_acme_email: "stacks@amido.com",
                      TF_VAR_is_cluster_private: true,
                      TF_VAR_cluster_version: $(aks_cluster_version),
                      TF_VAR_stage: nonprod,
                      TF_VAR_key_vault_name: "$(project)-$(domain)-nonprod-euw",
                      TF_VAR_dns_zone: $(base_domain_nonprod),
                      TF_VAR_internal_dns_zone: $(base_domain_internal_nonprod),
                      TF_VAR_pfx_password: "Password1",
                      TF_VAR_create_dns_zone: $(create_dns_zone),
                      TF_VAR_dns_resource_group: $(dns_resource_group),
                      TF_VAR_create_aksvnet: true,
                      TF_VAR_create_user_identity: true,
                      TF_VAR_acr_resource_group: "",
                      TF_VAR_log_application_type: "other",
                    }
                    terraform_output_commands: |
                      raw_tf=$(terraform output -json | jq -r 'keys[] as $k | "##vso[task.setvariable variable=\($k | ascii_upcase);isOutput=true]\(.[$k] | .value)"')
                      readarray -t outputs <<<"$raw_tf"
                      for i in "${outputs[@]}"; do echo "$i"; done

      - deployment: K8sNonProd
        dependsOn: InfraNonProd
        environment: ${{ variables.domain }}-nonprod
        variables:
          AKS_DEFAULT_USER_IDENTITY_CLIENT_ID: $[ dependencies.InfraNonProd.outputs['InfraNonProd.tfoutputs.AKS_DEFAULT_USER_IDENTITY_CLIENT_ID'] ]
          AKS_DEFAULT_USER_IDENTITY_ID: $[ dependencies.InfraNonProd.outputs['InfraNonProd.tfoutputs.AKS_DEFAULT_USER_IDENTITY_ID'] ]
          AKS_DEFAULT_USER_IDENTITY_NAME: $[ dependencies.InfraNonProd.outputs['InfraNonProd.tfoutputs.AKS_DEFAULT_USER_IDENTITY_NAME'] ]
          AKS_INGRESS_PUBLIC_IP: $[ dependencies.InfraNonProd.outputs['InfraNonProd.tfoutputs.AKS_INGRESS_PUBLIC_IP'] ]
          AKS_INGRESS_PRIVATE_IP: $[ dependencies.InfraNonProd.outputs['InfraNonProd.tfoutputs.AKS_INGRESS_PRIVATE_IP'] ]
          RESOURCE_GROUP: $[ dependencies.InfraNonProd.outputs['InfraNonProd.tfoutputs.RESOURCE_GROUP_NAME'] ]
          AKS_RESOURCE_GROUP: $[ dependencies.InfraNonProd.outputs['InfraNonProd.tfoutputs.AKS_RESOURCE_GROUP_NAME'] ]
          AKS_CLUSTER_NAME: $[ dependencies.InfraNonProd.outputs['InfraNonProd.tfoutputs.AKS_CLUSTER_NAME'] ]
          ACR_REGISTRY_NAME: $[ dependencies.InfraNonProd.outputs['InfraNonProd.tfoutputs.ACR_REGISTRY_NAME'] ]
        pool:
          vmImage: $(pool_vm_image)
        container: k8s_deploy
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self

                - checkout: templates

                - template: azDevOps/azure/templates/v2/steps/yaml-k8s-templater.yml@templates
                  parameters:
                    scripts_dir: $(scripts_dir)
                    # comment for debug and if you want to see the templated out file in the STDOUT of pipeline
                    enable_debug: "yes"
                    template_input: [
                      {
                        base: $(k8s_manifest_directory)/aks/base_external-dns.yml,
                        out: $(k8s_manifest_directory)/aks/external-dns.yml,
                        displayName: ExternalDns,
                        env_vars: {
                          domain_filter: $(base_domain_nonprod),
                          aks_resource_group: $(AKS_RESOURCE_GROUP),
                        },
                        args: "-no-empty"
                      },
                      {
                        base: $(k8s_manifest_directory)/aks/base_aadpodidentity.yml,
                        displayName: AADPodId,
                        env_vars: {
                          user_identity_id: $(AKS_DEFAULT_USER_IDENTITY_ID),
                          identity_client_id: $(AKS_DEFAULT_USER_IDENTITY_CLIENT_ID),
                          identity_user_name: $(AKS_DEFAULT_USER_IDENTITY_NAME),
                        },
                        args: "-no-empty"
                      },
                      {
                        base: $(k8s_manifest_directory)/aks/base_aadpodidentitybinding.yml,
                        displayName: AADPodIdBinding,
                        env_vars: {
                          identity_user_name: $(AKS_DEFAULT_USER_IDENTITY_NAME),
                        },
                        args: "-no-empty"
                      },
                      # If you've upgraded the ingress to helm, you may remove this and the template file.
                      # See MIGRATING guide for more details...
                      {
                        base: $(k8s_manifest_directory)/aks/base_nginx-ingress.yml,
                        out: $(k8s_manifest_directory)/aks/nginx-ingress.yml,
                        displayName: NginxIngress,
                        env_vars: {
                          aks_ingress_ip: $(AKS_INGRESS_PRIVATE_IP),
                          LB_IS_INTERNAL: "true",
                        },
                        args: "-no-empty"
                      },
                      ## Helm
                      {
                        base: '$(helm_manifest_directory)/base_ingress-nginx.yml',
                        out: '$(helm_manifest_directory)/ingress-nginx.yml',
                        displayName: "Helm: ingress-nginx",
                        env_vars: {
                          aks_ingress_ip: $(AKS_INGRESS_PRIVATE_IP),
                          aks_ingress_replica_count: 2,
                          commit_sha: $(Build.SourceVersion),
                          lb_is_internal: "true",
                        },
                        args: "-no-empty",
                      },
                    ]

                # Set to true to remove non-helm installed nginx Ingress. See MIGRATING guide for more details...
                - template: azDevOps/azure/templates/v2/steps/delete-non-helm-nginx-ingress-aks.yml@templates
                  parameters:
                    enable: true
                    template_name: $(k8s_manifest_directory)/aks/nginx-ingress.yml
                    # Azure
                    azure_tenant_id: $(azure-tenant-id)
                    azure_subscription_id: $(azure-subscription-id)
                    azure_client_id: $(azure-client-id)
                    azure_client_secret: $(azure-client-secret)
                    # Kubernetes
                    aks_resource_group_name: $(AKS_RESOURCE_GROUP)
                    aks_cluster_name: $(AKS_CLUSTER_NAME)
                    aks_set_acr_perms: false
                    acr_name: $(docker_container_registry_name)
                    acr_resource_group_name: $(AKS_RESOURCE_GROUP)
                    # Helm
                    helm_container: "k8s_deploy"
                    display_name: ingress-nginx
                    namespace: ingress-nginx

                - template: azDevOps/azure/templates/v2/steps/deploy-k8s-cluster.yml@templates
                  parameters:
                    scripts_dir: $(scripts_dir)
                    azure_tenant_id: $(azure-tenant-id)
                    azure_subscription_id: $(azure-subscription-id)
                    azure_client_id: $(azure-client-id)
                    azure_client_secret: $(azure-client-secret)
                    aks_cluster_name: $(AKS_CLUSTER_NAME)
                    aks_resource_group_name: $(AKS_RESOURCE_GROUP)
                    aks_dns_resource_group_name: $(AKS_RESOURCE_GROUP)
                    aks_set_acr_perms: false
                    aks_deploy_gatekeeper: false
                    aks_aad_pod_identity: false
                    aks_aad_pod_identity_yaml: {
                      aad_id_yml: $(k8s_manifest_directory)/aks/aadpodidentity.yml,
                      aad_id_binding_yml: $(k8s_manifest_directory)/aks/aadpodidentitybinding.yml
                    }
                    acr_name: $(docker_container_registry_name)
                    acr_resource_group_name: $(AKS_RESOURCE_GROUP)
                    ingress_definition:
                      helm_parameters_file: '$(helm_manifest_directory)/ingress-nginx.yml'
                      display_name: ingress-nginx,
                      namespace: ingress-nginx,
                      chart_name: ingress-nginx/ingress-nginx
                      chart_version: '4.4.2'
                    external_dns: false
                    external_dns_yml: $(k8s_manifest_directory)/aks/external-dns.yml
                    domain_filter: $(base_domain_nonprod)

  - stage: Prod
    dependsOn: Build
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
    variables:
      - group: amido-stacks-infra-credentials-prod

      # Pull in the production credentials for the build to use
      - group: stacks-credentials-prod-kv
      - name: Environment.ShortName
        value: prod
    jobs:
      - deployment: InfraProd
        environment: ${{ variables.domain }}-prod
        variables:
          ARM_SUBSCRIPTION_ID: $(azure-subscription-id)
          ARM_CLIENT_ID: $(azure-client-id)
          ARM_CLIENT_SECRET: $(azure-client-secret)
          ARM_TENANT_ID: $(azure-tenant-id)
        pool:
          vmImage: $(pool_vm_image)
        container: terraform_custom
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self

                - checkout: templates

                # Create TF infra
                - template: azDevOps/azure/templates/v2/steps/deploy-terraform-resource.yml@templates
                  parameters:
                    # Terraform Basic Config
                    terraform_working_dir: '$(self_repo_tf_dir)'
                    # changing this would require changing the downstream consumers of these outputs
                    terraform_output_artefact: 'tfoutputs'
                    # Terraform State Config
                    terraform_backend_client_id: $(ARM_CLIENT_ID)
                    terraform_backend_client_secret: $(ARM_CLIENT_SECRET)
                    terraform_backend_tenant_id: $(ARM_TENANT_ID)
                    terraform_backend_subscription_id: $(ARM_SUBSCRIPTION_ID)
                    terraform_state_rg: $(tf_state_rg)
                    terraform_state_storage: $(tf_state_storage)
                    terraform_state_container: $(tf_state_container)
                    terraform_state_key: $(tf_state_key)
                    # Azure Config
                    azure_client_id: "$(ARM_CLIENT_ID)"
                    azure_client_secret: "$(ARM_CLIENT_SECRET)"
                    azure_tenant_id: "$(ARM_TENANT_ID)"
                    azure_subscription_id: "$(ARM_SUBSCRIPTION_ID)"
                    terraform_state_workspace: prod
                    tags: ''
                    # Terraform Resource Specific Config
                    terraform_extra_properties: {
                      TF_VAR_resource_group_location: $(region),
                      TF_VAR_name_company: $(company),
                      TF_VAR_name_project: $(project),
                      TF_VAR_name_component: $(domain),
                      TF_VAR_name_environment: prod,
                      TF_VAR_create_acr: true,
                      TF_VAR_acme_email: "stacks@amido.com",
                      TF_VAR_is_cluster_private: true,
                      TF_VAR_cluster_version: $(aks_cluster_version),
                      TF_VAR_stage: prod,
                      TF_VAR_key_vault_name: "$(project)-$(domain)-prod-euw",
                      TF_VAR_dns_zone: $(base_domain_prod),
                      TF_VAR_internal_dns_zone: $(base_domain_internal_prod),
                      TF_VAR_pfx_password: "Password1",
                      TF_VAR_create_dns_zone: $(create_dns_zone),
                      TF_VAR_dns_resource_group: $(dns_resource_group),
                      TF_VAR_create_aksvnet: true,
                      TF_VAR_create_user_identity: true,
                      TF_VAR_acr_resource_group: "",
                      TF_VAR_log_application_type: "other",
                    }
                    terraform_output_commands: |
                      raw_tf=$(terraform output -json | jq -r 'keys[] as $k | "##vso[task.setvariable variable=\($k | ascii_upcase);isOutput=true]\(.[$k] | .value)"')
                      readarray -t outputs <<<"$raw_tf"
                      for i in "${outputs[@]}"; do echo "$i"; done

      - deployment: K8sProd
        dependsOn: InfraProd
        environment: ${{ variables.domain}}-prod
        variables:
          AKS_DEFAULT_USER_IDENTITY_CLIENT_ID: $[ dependencies.InfraProd.outputs['InfraProd.tfoutputs.AKS_DEFAULT_USER_IDENTITY_CLIENT_ID'] ]
          AKS_DEFAULT_USER_IDENTITY_ID: $[ dependencies.InfraProd.outputs['InfraProd.tfoutputs.AKS_DEFAULT_USER_IDENTITY_ID'] ]
          AKS_DEFAULT_USER_IDENTITY_NAME: $[ dependencies.InfraProd.outputs['InfraProd.tfoutputs.AKS_DEFAULT_USER_IDENTITY_NAME'] ]
          AKS_INGRESS_PUBLIC_IP: $[ dependencies.InfraProd.outputs['InfraProd.tfoutputs.AKS_INGRESS_PUBLIC_IP'] ]
          AKS_INGRESS_PRIVATE_IP: $[ dependencies.InfraProd.outputs['InfraProd.tfoutputs.AKS_INGRESS_PRIVATE_IP'] ]
          RESOURCE_GROUP: $[ dependencies.InfraProd.outputs['InfraProd.tfoutputs.RESOURCE_GROUP_NAME'] ]
          AKS_RESOURCE_GROUP: $[ dependencies.InfraProd.outputs['InfraProd.tfoutputs.AKS_RESOURCE_GROUP_NAME'] ]
          AKS_CLUSTER_NAME: $[ dependencies.InfraProd.outputs['InfraProd.tfoutputs.AKS_CLUSTER_NAME'] ]
          ACR_REGISTRY_NAME: $[ dependencies.InfraProd.outputs['InfraProd.tfoutputs.ACR_REGISTRY_NAME'] ]
        pool:
          vmImage: $(pool_vm_image)
        container: k8s_deploy
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self

                - checkout: templates

                - template: azDevOps/azure/templates/v2/steps/yaml-k8s-templater.yml@templates
                  parameters:
                    scripts_dir: $(scripts_dir)
                    # comment for debug and if you want to see the templated out file in the STDOUT of pipeline
                    enable_debug: "yes"
                    template_input: [
                      {
                        base: $(k8s_manifest_directory)/aks/base_external-dns.yml,
                        out: $(k8s_manifest_directory)/aks/external-dns.yml,
                        displayName: ExternalDns,
                        env_vars: {
                          domain_filter: $(base_domain_prod),
                          aks_resource_group: $(AKS_RESOURCE_GROUP),
                        },
                        args: "-no-empty"
                      },
                      {
                        base: $(k8s_manifest_directory)/aks/base_aadpodidentity.yml,
                        displayName: AADPodId,
                        env_vars: {
                          user_identity_id: $(AKS_DEFAULT_USER_IDENTITY_ID),
                          identity_client_id: $(AKS_DEFAULT_USER_IDENTITY_CLIENT_ID),
                          identity_user_name: $(AKS_DEFAULT_USER_IDENTITY_NAME),
                        },
                        args: "-no-empty"
                      },
                      {
                        base: $(k8s_manifest_directory)/aks/base_aadpodidentitybinding.yml,
                        displayName: AADPodIdBinding,
                        env_vars: {
                          identity_user_name: $(AKS_DEFAULT_USER_IDENTITY_NAME)
                        },
                        args: "-no-empty"
                      },
                      # If you've upgraded the ingress to helm, you may remove this and the template file.
                      # See MIGRATING guide for more details...
                      {
                        base: $(k8s_manifest_directory)/aks/base_nginx-ingress.yml,
                        out: $(k8s_manifest_directory)/aks/nginx-ingress.yml,
                        displayName: NginxIngress,
                        env_vars: {
                          aks_ingress_ip: $(AKS_INGRESS_PRIVATE_IP),
                          LB_IS_INTERNAL: "true",
                        },
                        args: "-no-empty"
                      },
                      ## Helm
                      {
                        base: '$(helm_manifest_directory)/base_ingress-nginx.yml',
                        out: '$(helm_manifest_directory)/ingress-nginx.yml',
                        displayName: "Helm: ingress-nginx",
                        env_vars: {
                          aks_ingress_ip: $(AKS_INGRESS_PRIVATE_IP),
                          aks_ingress_replica_count: 2,
                          commit_sha: $(Build.SourceVersion),
                          lb_is_internal: "true",
                        },
                        args: "-no-empty",
                      },
                    ]

                # Set to true to remove non-helm installed nginx Ingress. See MIGRATING guide for more details...
                - template: azDevOps/azure/templates/v2/steps/delete-non-helm-nginx-ingress-aks.yml@templates
                  parameters:
                    enable: true
                    template_name: $(k8s_manifest_directory)/aks/nginx-ingress.yml
                    # Azure
                    azure_tenant_id: $(azure-tenant-id)
                    azure_subscription_id: $(azure-subscription-id)
                    azure_client_id: $(azure-client-id)
                    azure_client_secret: $(azure-client-secret)
                    # Kubernetes
                    aks_resource_group_name: $(AKS_RESOURCE_GROUP)
                    aks_cluster_name: $(AKS_CLUSTER_NAME)
                    aks_set_acr_perms: false
                    acr_name: $(docker_container_registry_name)
                    acr_resource_group_name: $(AKS_RESOURCE_GROUP)
                    # Helm
                    helm_container: "k8s_deploy"
                    display_name: ingress-nginx
                    namespace: ingress-nginx

                - template: azDevOps/azure/templates/v2/steps/deploy-k8s-cluster.yml@templates
                  parameters:
                    scripts_dir: $(scripts_dir)
                    azure_tenant_id: $(azure-tenant-id)
                    azure_subscription_id: $(azure-subscription-id)
                    azure_client_id: $(azure-client-id)
                    azure_client_secret: $(azure-client-secret)
                    aks_cluster_name: $(AKS_CLUSTER_NAME)
                    aks_resource_group_name: $(AKS_RESOURCE_GROUP)
                    aks_dns_resource_group_name: $(AKS_RESOURCE_GROUP)
                    aks_set_acr_perms: false
                    aks_deploy_gatekeeper: false
                    helm_container: "k8s_deploy"
                    helm_repositories:
                      ingress-nginx: https://kubernetes.github.io/ingress-nginx
                    aks_aad_pod_identity: false
                    aks_aad_pod_identity_yaml: {
                      aad_id_yml: $(k8s_manifest_directory)/aks/aadpodidentity.yml,
                      aad_id_binding_yml: $(k8s_manifest_directory)/aks/aadpodidentitybinding.yml,
                    }
                    acr_name: $(docker_container_registry_name)
                    acr_resource_group_name: $(AKS_RESOURCE_GROUP)
                    ingress_definition:
                      helm_parameters_file: '$(helm_manifest_directory)/ingress-nginx.yml'
                      display_name: ingress-nginx,
                      namespace: ingress-nginx,
                      chart_name: ingress-nginx/ingress-nginx
                      chart_version: '4.4.2'
                    external_dns: false
                    external_dns_yml: $(k8s_manifest_directory)/aks/external-dns.yml
                    domain_filter: $(base_domain_prod)

  - stage: Release
    dependsOn:
      - Build
      - Prod
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'), eq(variables['create_release'], 'true'))
    variables:
      - group: amido-stacks-infra-credentials-nonprod
      - name: version_number
        value: "$(version_major).$(version_minor).$(version_revision)"
    jobs:
      - job: CreateGitHubRelease
        pool:
          vmImage: $(pool_vm_image)
        steps:
          # Check out the repo so that it can be tagged
          - checkout: self
            persistCredentials: true

          # Create a tag in the code for this release
          - task: Bash@3
            displayName: Tag Code
            inputs:
              targetType: "inline"
              script: |
                git config user.name "BuildService"
                git config user.email "builder@${COMPANY}.com"
                git tag -a v${VERSION_NUMBER} -m "Release created by Azure DevOps"
                git push origin v${VERSION_NUMBER}
            env:
              COMPANY: $(company)

          # Create a GitHub release with these packages
          - task: GitHubRelease@0
            displayName: Create GitHub Release
            inputs:
              gitHubConnection: $(github_release_service_connection)
              repositoryName: $(github_org)/$(self_repo)
              tag: $(Build.BuildNumber)
